## 문제 풀이

### 문제 링크
[1932. 정수 삼각형 – 백준](https://www.acmicpc.net/problem/1932)

---

### 문제 설명
> 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아야 한다. 이동은 현재 위치에서 아래층의 왼쪽 대각선 또는 오른쪽 대각선으로만 가능하다.

---

### 접근 방식
1.  **동적 계획법 (Dynamic Programming)** 사용
2.  `dp[i][j]`를 `i`행 `j`열까지 도달했을 때의 최대 합이라고 정의한다.
3.  현재 위치 `(i, j)`로 올 수 있는 이전 위치는:
    -   왼쪽 위 대각선: `(i-1, j-1)`
    -   오른쪽 위 대각선: `(i-1, j)` (인덱스상 바로 위)
4.  점화식:
    -   가장 왼쪽(`j==0`)인 경우: 바로 위(`dp[i-1][j]`)에서만 올 수 있다.
    -   가장 오른쪽(`j==i`)인 경우: 왼쪽 위(`dp[i-1][j-1]`)에서만 올 수 있다.
    -   그 외의 경우: `max(dp[i-1][j-1], dp[i-1][j]) + 현재값`
    -   _참고: 이 풀이에서는 입력을 받을 때 바로 DP 테이블을 갱신하는 방식을 사용하였다._
5.  모든 입력 처리가 끝난 후, 마지막 행(`dp[n-1]`)의 값들 중 최댓값을 출력한다.

---

### 풀이 코드

```cpp
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {

    int n;
    cin >> n;

    vector<int> dp(n, 0);

    for (int i = 0; i < n; i++) {
        for (int j = i; j >= 0; j--) {   
            int x;
            cin >> x;

            if (j == 0) dp[j] = dp[j] + x;                 
            else if (j == i) dp[j] = dp[j - 1] + x;         
            else dp[j] = max(dp[j], dp[j - 1]) + x;         
        }
    }

    cout << *max_element(dp.begin(), dp.end()) << "\n";
}
```
