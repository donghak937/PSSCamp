## 문제 풀이

### 문제 링크
[2110. 공유기 설치 – 백준](https://www.acmicpc.net/problem/2110)

---

### 문제 설명
> 도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 $x_1, ..., x_N$이고, 집 여러 개가 같은 좌표를 가지는 일은 없다.
> 도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
> C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

---

### 접근 방식
1.  **이분 탐색 (Binary Search)**, 그 중에서도 **파라메트릭 서치 (Parametric Search)** 를 사용한다.
2.  우리가 찾아야 하는 답은 "가장 인접한 두 공유기 사이의 거리의 최댓값"이다.
3.  이 거리를 `mid`라고 가정하고, `mid` 이상의 간격을 유지하면서 C개의 공유기를 설치할 수 있는지 확인한다.
4.  **결정 문제(Decision Problem)**: 거리 `mid` 이상으로 C개의 공유기를 설치할 수 있는가?
    -   집들을 좌표 정렬한다.
    -   첫 번째 집에 공유기를 설치한다.
    -   직전에 설치한 집과의 거리가 `mid` 이상인 가장 가까운 집에 다음 공유기를 설치한다. (Greedy)
    -   설치된 공유기의 개수가 C개 이상이면 가능, 미만이면 불가능.
5.  이분 탐색 범위 설정:
    -   `lo`: 최소 거리는 1
    -   `hi`: 최대 거리는 `양 끝 집 사이의 거리 (x[N-1] - x[0])`
6.  `mid` 거리로 설치 가능하다면, 더 멀리 설치해도 되는지 확인하기 위해 `lo`를 증가시킨다 (`lo = mid + 1`, `ans` 갱신).
7.  불가능하다면, 거리를 좁혀야 하므로 `hi`를 감소시킨다 (`hi = mid - 1`).

---

### 풀이 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int N, C;
    cin >> N >> C;

    vector<long long> x(N);
    for (int i = 0; i < N; i++) cin >> x[i];
    sort(x.begin(), x.end());

    long long lo = 1;
    long long hi = x.back() - x.front();
    long long ans = 0;

    while (lo <= hi) {
        long long mid = lo + (hi - lo) / 2;

        long long last = x[0];
        int cnt = 1; 

        for (int i = 1; i < N; i++) {
            if (x[i] - last >= mid) {
                cnt++;
                last = x[i];
            }
        }

        if (cnt >= C) {  
            ans = mid;
            lo = mid + 1;
        } else {        
            hi = mid - 1;
        }
    }

    cout << ans << "\n";
}
```
