## 문제 풀이

### 문제 링크
[덧칠하기 – 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/161989)

---

### 문제 설명
> 어느 학교에 페인트가 칠해진 길이가 `n`미터인 벽이 있습니다. 벽에 페인트가 벗겨진 구역들이 있는데, 이를 롤러를 이용해 다시 칠하려고 합니다. 벽은 1번부터 `n`번까지 구역으로 나뉘어 있고, 롤러의 길이는 `m`미터입니다.
> 롤러는 한 번 칠할 때 구역 `m`개를 동시에 칠할 수 있습니다. 페인트가 벗겨진 모든 구역을 칠하기 위해 필요한 롤러칠의 최소 횟수를 구하는 문제입니다.
> (롤러는 반드시 벽의 구역 안에서만 칠할 수 있다는 등의 제약사항은 있으나, 알고리즘적으로는 **'벗겨진 구역을 모두 커버하는 최소 횟수'** 가 핵심입니다.)

---

### 접근 방식
1.  **그리디 알고리즘 (Greedy Algorithm)** 사용:
    -   페인트가 벗겨진 구역(`section`)을 순서대로 확인합니다.
    -   현재 칠해야 할 구역이, 이전에 칠한 롤러의 범위(`current`) 내에 있다면, 이미 칠해진 것이므로 넘어갑니다.
    -   범위를 벗어났다면, **그 구역을 시작점**으로 하여 롤러를 새로 칠합니다.
2.  **구체적 로직**:
    -   `current` 변수를 사용하여 현재 롤러가 커버하고 있는 **마지막 구역 번호**를 저장합니다. 초기값은 0입니다.
    -   `section` 배열의 각 요소 `s`에 대해:
        -   `s > current`라면 (즉, 아직 칠해지지 않은 벗겨진 구역이라면):
            -   새로운 롤러질이 필요하므로 `answer++`
            -   이번 롤러질은 `s`부터 시작해서 `s + m - 1`까지 칠하게 됩니다. 따라서 `current = s + m - 1`로 갱신합니다.
        -   `s <= current`라면 (이미 이전 롤러질 범위에 포함된다면):
            -   아무것도 하지 않고 (`continue`) 넘어갑니다.

---

### 풀이 코드

```cpp
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;


int main() {
    int n = 5, m = 2; 
    vector<int> section = {1, 4, 5};
    int answer = 0;
    int current = 0;

    for(int i = 0; i < section.size(); i++){
        if (current >= section[i]) continue;
        else{
            current = section[i] + m - 1;
            answer++;
        }
    }

    cout << answer;
}
```
