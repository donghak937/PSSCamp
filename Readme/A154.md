## 문제 풀이

### 문제 링크
[13305. 주유소 – 백준](https://www.acmicpc.net/problem/13305)

---

### 문제 설명
> 어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로를 이용할 때에는 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격이 제일 싼 주유소에서 많이 사서 이동하는 것이 이득이다.
> 각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.

---

### 접근 방식
1.  **그리디 알고리즘 (Greedy Algorithm)** 사용
2.  현재 도시의 기름값이 다음 도시(혹은 그 이후의 도시들)보다 싸다면, 그 도시까지 갈 수 있는 기름을 미리 사는 것이 이득이다.
3.  단순히 바로 다음 도시랑만 비교하는 것이 아니라, **"나보다 싼 주유소가 나올 때까지"**의 거리만큼을 현재 주유소의 가격으로 계산한다.
4.  구체적인 로직:
    -   현재 주유소(`i`)에서 시작하여, 이후 주유소들(`j`)을 탐색한다.
    -   `j`번째 주유소의 가격이 `i`번째보다 작아질 때까지 거리를 누적(`distan`)한다.
    -   나보다 싼 주유소를 발견하거나(`costs[i] > costs[j]`), 마지막 도시에 도달하면:
        -   누적된 거리만큼 현재 가격(`costs[i]`)으로 비용을 계산하여 `total`에 더한다.
        -   현재 위치 `i`를 `j-1`로 갱신하여, 다음 반복문이 해당 싼 주유소부터 시작하도록 한다.
5.  입력 범위가 크므로(거리 합 최대 10억, 가격 최대 10억) `long long` 자료형을 사용한다.

---

### 풀이 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    long long n;
    vector<long long> dis;
    vector<long long> costs;

    long long total = 0;
    long long distan = 0;

    cin >> n;

    for(long long i = 0; i < n - 1; i++){
        long long a;
        cin >> a;
        dis.push_back(a);
    }

    for(long long i = 0; i < n; i++){
        long long a;
        cin >> a;
        costs.push_back(a);
    }

    for(long long i = 0; i < n; i++){
        for(long long j = i+1; j < n; j++){
            distan += dis[j-1];
            if (costs[i] > costs[j] || j == n - 1){
                total += distan * costs[i];
                distan = 0;
                i = j-1;
                break;
            }
        }
    }

    cout << total;

}
```
