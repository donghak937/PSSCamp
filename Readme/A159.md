## 문제 풀이

### 문제 링크
[바탕화면 정리 – 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/161990)

---

### 문제 설명
> 코딩테스트를 준비하는 머쓱이는 컴퓨터 바탕화면의 파일들을 정리하려고 합니다. 바탕화면은 각 칸이 정사각형인 격자판이고, 각 칸은 빈칸(`.`) 또는 파일(`#`)로 이루어져 있습니다.
> 파일들을 한 번에 드래그하여 삭제하려고 하는데, 드래그는 `(lux, luy)`에서 `(rdx, rdy)`까지 직사각형 범위로 선택할 수 있습니다.
> 이때 선택된 범위 내의 모든 파일이 포함되어야 하며, 드래그 거리가 최소가 되는 좌표를 구하는 문제입니다.
> 드래그 거리는 `|rdx - lux| + |rdy - luy|`로 정의되지만, 사실상 우리가 구해야 하는 것은 **모든 파일을 포함하는 최소 크기의 직사각형**의 좌측 상단 `(lux, luy)`와 우측 하단 `(rdx, rdy)` 좌표입니다.

---

### 접근 방식
1.  **최소/최대 좌표 찾기**:
    -   바탕화면에 있는 파일(`#`)들의 위치를 모두 확인합니다.
    -   가장 위쪽에 있는 파일의 행 인덱스 (`lux`), 가장 아래쪽에 있는 파일의 행 인덱스 (`rdx`), 가장 왼쪽에 있는 파일의 열 인덱스 (`luy`), 가장 오른쪽에 있는 파일의 열 인덱스 (`rdy`)를 찾습니다.
    -   이때, 드래그의 **시작점(lux, luy)** 은 파일 중 가장 작은 행/열 인덱스가 됩니다.
    -   드래그의 **끝점(rdx, rdy)** 은 파일 중 가장 큰 행/열 인덱스에 **+1**을 한 값이 됩니다. (파일은 1x1 크기를 차지하므로, 해당 인덱스의 파일을 포함하려면 끝점은 그 다음 칸이어야 함)
2.  **초기값 설정**:
    -   `lux`, `luy`는 최솟값을 찾아야 하므로 충분히 큰 값(예: `51` 또는 `INT_MAX`)으로 초기화합니다.
    -   `rdx`, `rdy`는 최댓값을 찾아야 하므로 작은 값(`0`)으로 초기화합니다.
3.  **순회 및 갱신**:
    -   `wallpaper`를 이중 반복문으로 순회하며 `#`을 만날 때마다 좌표를 갱신합니다.

---

### 풀이 코드

```cpp
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;


int main() {

    vector<string> wallpaper = {"..", "#."};
    vector<int> answer;

    int x1 = 99, y1 = 99, x2 = 0, y2 = 0;

    for(int i = 0; i < wallpaper.size(); i++){
        for(int j = 0; j < wallpaper[0].size(); j++){
            if (wallpaper[i][j] == '#'){
                if(i < x1) x1 = i; 
                if(i > x2) x2 = i; 
                if(j < y1) y1 = j; 
                if(j > y2) y2 = j; 
            }

        }
    }

    answer.push_back(x1);
    answer.push_back(y1);
    answer.push_back(x2+1);
    answer.push_back(y2+1);

    
}
```
