## 문제 풀이

### 문제 링크
[달리기 경주 – 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/178871)

---

### 문제 설명
> 얀에서는 매년 달리기 경주가 열립니다. 해설진들은 선수들이 자기 바로 앞의 선수를 추월할 때 추월한 선수의 이름을 부릅니다.
> 예를 들어 1등부터 3등까지 "mumu", "soe", "poe" 선수들이 순서대로 달리고 있을 때, 해설진이 "soe"선수를 불렀다면 2등인 "soe" 선수가 1등인 "mumu" 선수를 추월했다는 것입니다. 즉 "soe" 선수가 1등, "mumu" 선수가 2등으로 바뀝니다.
> 선수들의 이름이 1등부터 현재 등수 순서대로 담긴 문자열 배열 `players`와 해설진이 부른 이름을 담은 문자열 배열 `callings`가 매개변수로 주어질 때, 경주가 끝났을 때 선수들의 이름을 1등부터 등수 순서대로 배열에 담아 return 하는 solution 함수를 완성해주세요.

---

### 접근 방식
1.  **해시 맵 (Unordered Map) 사용**:
    -   `players` 배열만 사용할 경우, `callings`에 있는 이름을 찾기 위해 매번 `find`나 루프를 사용하면 $O(N)$ 시간이 걸린다. `callings`의 길이가 최대 1,000,000이므로 시간 초과가 발생한다.
    -   따라서 `이름 -> 현재 등수(index)`를 저장하는 `unordered_map<string, int>`를 사용하여 등수 검색을 $O(1)$에 수행한다.
2.  **스왑 로직**:
    -   `callings`에서 불린 선수의 현재 등수(`idx`)를 맵에서 찾는다.
    -   해당 선수는 바로 앞 등수(`idx - 1`)와 위치를 바꾼다.
    -   `players` 배열에서 두 선수의 위치를 `swap`한다.
    -   **중요**: `map`에서도 두 선수의 등수 정보를 갱신한다.
3.  모든 `callings`를 처리한 후 최종 `players` 배열을 반환한다.

---

### 풀이 코드

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<string> solution(vector<string> players, vector<string> callings) {
    unordered_map<string, int> pos;

    // 초기 등수 매핑
    for (int i = 0; i < players.size(); i++) {
        pos[players[i]] = i;
    }
    
    for (const string& call : callings) {
        // 현재 불린 선수의 등수
        int curIdx = pos[call];
        
        // 앞서가던 선수 이름
        string frontPlayer = players[curIdx - 1];
        
        // players 배열에서 스왑
        // players[curIdx]는 call, players[curIdx-1]은 frontPlayer
        swap(players[curIdx], players[curIdx - 1]);
        
        // map에서 등수 갱신
        pos[call] = curIdx - 1;
        pos[frontPlayer] = curIdx;
    }
    
    return players;
}
```
