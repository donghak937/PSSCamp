## 문제 풀이

### 문제 링크
[1654. 랜선 자르기 – 백준](https://www.acmicpc.net/problem/1654)

---

### 문제 설명
> 집에서 시간을 보내던 오영식은 박성원에게 캠프 때 쓸 N개의 랜선을 만들어 달라는 부탁을 받았다.
> 하지만 오영식은 K개의 랜선을 가지고 있다. 이 K개의 랜선은 길이가 제각각이다.
> 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶어 한다. 우리는 K개의 랜선을 잘라서 만들어야 한다.
> 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)
> 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.

---

### 접근 방식
1.  **이분 탐색 (Binary Search)**, 그 중에서도 **파라메트릭 서치 (Parametric Search)** 를 사용한다.
2.  랜선의 길이는 자연수이므로, 1부터 가장 긴 랜선의 길이(`hi`) 사이의 범위에서 정답을 찾는다.
3.  특정 길이 `mid`로 잘랐을 때, 만들어지는 랜선의 개수(`pieces`)가:
    -   `N`개 이상이면: 더 길게 잘라도 될 가능성이 있으므로 `lo = mid + 1`로 범위를 높이고, `ans`를 `mid`로 갱신한다.
    -   `N`개 미만이면: 너무 길게 자른 것이므로 `hi = mid - 1`로 범위를 줄인다.
4.  입력 범위가 랜선 길이 최대 $2^{31}-1$, 개수 등에서 Integer 범위를 넘거나 계산 과정에서 오버플로우가 발생할 수 있으므로 `long long` 자료형을 사용한다.
5.  최적의 길이 `ans`를 출력한다.

---

### 풀이 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    long long k, n;
    vector<long long> len; 

    cin >> k >> n;
    long long hi = 0;

    for(int i = 0; i < k; i ++){
        long long a;
        cin >> a;
        len.push_back(a);

        if (a > hi) hi = a;
    }

    long long lo = 1;
    long long ans = 0;
    
    while (lo <= hi) {
        long long mid = (lo + hi) / 2;

        long long pieces = 0;
        for (int i = 0; i < k; i++) {
            pieces += len[i] / mid;
        }

        if (pieces >= n) {      
            ans = mid;
            lo = mid + 1;
        } else {                
            hi = mid - 1;
        }
    }
    cout << ans << "\n";

}
```
