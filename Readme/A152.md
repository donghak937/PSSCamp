## 문제 풀이

### 문제 링크
[2579. 계단 오르기 – 백준](https://www.acmicpc.net/problem/2579)

---

### 문제 설명
> 계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. 각 계단에는 점수가 있으며, 계단을 밟으면 그 계단의 점수를 얻는다. 계단을 오르는 규칙은 다음과 같다.
> 1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다.
> 2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. (단, 시작점은 계단에 포함되지 않는다.)
> 3. 마지막 도착 계단은 반드시 밟아야 한다.
> 이 규칙을 지키며 얻을 수 있는 총 점수의 최댓값을 구하는 문제.

---

### 접근 방식
1.  **동적 계획법 (Dynamic Programming)** 사용
2.  `dp[i]`를 `i`번째 계단에 도착했을 때의 최대 점수라고 정의한다.
3.  `i`번째 계단에 도달할 수 있는 경우의 수는 두 가지이다 (마지막 계단은 무조건 밟아야 하므로):
    -   **i-2번째 계단에서 바로 오는 경우**: 연속된 세 계단을 밟지 않는 조건을 만족한다.
        -   `dp[i-2] + score[i]`
    -   **i-3번째 계단에서 i-1번째 계단을 거쳐 오는 경우**: 연속된 세 계단을 밟으면 안 되므로, i-1번째 계단을 밟기 전에는 i-2번째가 아닌 i-3번째 계단을 밟았어야 한다.
        -   `dp[i-3] + score[i-1] + score[i]`
4.  따라서 점화식은: `dp[i] = max(dp[i-2], dp[i-3] + score[i-1]) + score[i]`
5.  초기값(1, 2, 3번째 계단)은 미리 설정해두고 4번째 계단부터 점화식을 적용한다.

---

### 풀이 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n;
    int dp[301]; // 계단의 최대 개수는 300
    int score[301];
    
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> score[i];
    }

    dp[1] = score[1];
    dp[2] = score[1] + score[2];
    dp[3] = max(score[1], score[2]) + score[3]; // 1->3 혹은 2->3 중 큰 값

    for(int i = 4; i <= n; i++){
        dp[i] = max(dp[i-2], dp[i-3] + score[i-1]) + score[i];
    }

    cout << dp[n];
}
```
